[manifest]
version = "1.0.4f-Theta"
dump_lua = true
priority = 0

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''G.SPLASH_BACK = Sprite(-30, -6, G.ROOM.T.w+60, G.ROOM.T.h+12, G.ASSET_ATLAS["ui_1"], {x = 2, y = 0})'''
position = "before"
payload = '''
    self.bm_wallet = CardArea(G.jokers.T.x, G.jokers.T.y, 4.9*G.CARD_W, 0.95*G.CARD_H, {
            card_limit = 5,
            type = "bm_wallet",
            highlight_limit = 1
    })
    self.bm_wallet.card_w=self.bm_wallet.card_w
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if self.highlighted and self.area and self.area.config.type ~= 'shop' then'''
position = "at"
payload = '''
if self.highlighted and self.area and self.area.config.type ~= 'shop' and self.area.config.type ~= 'new_shop' then
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if not self.states.focus.is and self.children.focused_ui then'''
position = "before"
payload = '''
if self.states.drag.is and self:can_mobile_card() then
    local prev_area = self:get_prev_area()
    local possible_areas = {prev_area, G.bm_wallet}
    possible_areas = remove_nils(possible_areas)
    local card_x = self.VT.x+self.VT.w/2
    local card_y = self.VT.y+self.VT.h/2
    for i, v in ipairs(possible_areas) do
        if v.T.x < card_x and card_x < v.T.x + v.T.w and v.T.y < card_y and card_y < v.T.y + v.T.h then
            if (self.area == nil or self.area ~= v) and (v == G.hand or v == G.shop_booster or v.config.card_limit > #v.cards) and (self.area ~= G.shop_booster) then
                if (G.GAME.exchange == nil and v == G.bm_wallet) or (G.GAME.exchange == true and v == G.jokers) then
                    return
                end
                if v == G.hand and not (G.hand and G.hand.cards[1]) then
                    return
                end
                if self.area then
                    self.area:remove_card(self)
                end
                v:emplace(self)
                if v.config.type == 'shop' then
                    if not (self.children.price or self.children.buy_button) then
                        create_shop_card_ui(self)
                    end
                end
            end
        end          
    end
end
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''if (not v.parent and v ~= self.CONTROLLER.dragging.target and v ~= self.CONTROLLER.focused.target) then'''
position = "before"
payload = '''
]]
        for k, v in pairs(self.I.CARDAREA) do
            if not v.parent then 
                love.graphics.push()
                v:translate_container()
                v:draw()
                love.graphics.pop()
            end
        end
    else
    if (not self.OVERLAY_MENU) or (not self.F_HIDE_BG) then 
        timer_checkpoint('primatives', 'draw')
        for k, v in pairs(self.I.UIBOX) do
            if not v.attention_text and not v.parent and v ~= self.OVERLAY_MENU and v ~= self.screenwipe and v ~= self.OVERLAY_TUTORIAL and v ~= self.debug_tools and v ~= self.online_leaderboard and v ~= self.achievement_notification then 
                love.graphics.push()
                v:translate_container()
                v:draw()
                love.graphics.pop()
            end
        end
            timer_checkpoint('uiboxes', 'draw')
        for k, v in pairs(self.I.CARDAREA) do
            if not v.parent then
            if G.GAME.exchange == nil then
                if v ~= G.bm_wallet then
                    love.graphics.push()
                    v:translate_container()
                    v:draw()
                    love.graphics.pop()
                end
            else
                if v ~= G.jokers then
                    love.graphics.push()
                    v:translate_container()
                    v:draw()
                    love.graphics.pop()
                end
            end
            end
        end

        for k, v in pairs(self.I.CARD) do
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''if G.debug_splash_size_toggle then'''
position = "after"
payload = '''
--[[
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''self.HUD = UIBox{'''
position = "before"
payload = '''

local t = create_UIBox_HUD()
local raw_contents_buttons = t.nodes[1].nodes[1].nodes[5].nodes[1].nodes
local raw_run_info = raw_contents_buttons[1].nodes[1]
local raw_options = raw_contents_buttons[1].nodes[2]
local raw_contents_buttons_in = raw_contents_buttons[1].nodes
raw_run_info.config.minh = 1.5
raw_options.config.minh = 1.1
raw_contents_buttons_in[#raw_contents_buttons_in + 1] = {n=G.UIT.R, config={align = "cm", minh = 0.8, minw = 1.5,padding = 0.05, r = 0.1, hover = true, colour = G.C.BLUE, button = "set_exchange", shadow = true}, nodes={
    {n=G.UIT.C, config={align = "cm", maxw = 1.4, focus_args = {button = 'start', orientation = 'bm'}, func = 'set_button_pip'}, nodes={
        {n=G.UIT.T, config={text = localize('b_switch'), scale = 0.4, colour = G.C.UI.TEXT_LIGHT, shadow = true}}
    }},
}}
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''definition = create_UIBox_HUD(),'''
position = "at"
payload = '''
definition = t,
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''perma_bonus = self.ability and self.ability.perma_bonus or 0,'''
position = "before"
payload = '''
f_level = self.ability and self.ability.f_level or 0,
f_chips = self.ability and self.ability.f_chips or 0,
f_mult = self.ability and self.ability.f_mult or 0,
f_x_mult = self.ability and self.ability.f_x_mult or 0,
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''--matches with any new changes of compatibility determined by the Joker'''
position = "after"
payload = '''

G.FUNCS.check_drag_target_active = function(e)
    if e.config.args.active_check(e.config.args.card) then
        if (not e.config.pulse_border) or not e.config.args.init then
            e.config.pulse_border = true
            e.config.colour = e.config.args.colour
            e.config.args.text_colour[4] = 1
            e.config.release_func = e.config.args.release_func
        end
    else
        if (e.config.pulse_border) or not e.config.args.init then 
            e.config.pulse_border = nil
            e.config.colour = adjust_alpha(G.C.L_BLACK, 0.9)
            e.config.args.text_colour[4] = 0.5
            e.config.release_func = nil
        end
    end
    e.config.args.init = true
end

G.FUNCS.can_buy_touch = function(_card)
    if _card.cost > (G.GAME.dollars - G.GAME.bankrupt_at) and (_card.cost > 0) then
        return false
    end
    return true
end

G.FUNCS.can_use_touch = function(_card)
    if not _card.ability.consumeable then
        return false
    end
    if (not _card:can_use_consumeable()) then
        return false
    end
    return true
end

G.FUNCS.can_buy_and_use_touch = function(_card)
    if not _card.ability.consumeable then
        return false
    end
    if (((_card.cost > G.GAME.dollars - G.GAME.bankrupt_at) and (_card.cost > 0)) or (not _card:can_use_consumeable())) then
        return false
    end
    return true
end

G.FUNCS.can_select_card_touch = function(_card)
    if _card.ability.set ~= 'Joker' or (_card.edition and _card.edition.negative) or #G.jokers.cards < G.jokers.config.card_limit then 
        return true
    end
    return false
end

G.FUNCS.can_sell_card_touch = function(_card)
    if _card:can_sell_card() then 
        return true
    else
        return false
    end
end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = '''function boot_timer(_label, _next, progress)'''
position = "before"
payload = '''
function create_drag_target_from_card(_card)
    if _card and G.STAGE == G.STAGES.RUN then
        G.DRAG_TARGETS = G.DRAG_TARGETS or {
            S_buy = Moveable{T={x = G.jokers.T.x, y = G.jokers.T.y - 0.1, w = G.consumeables.T.x + G.consumeables.T.w - G.jokers.T.x, h = G.jokers.T.h+0.6}},
            S_buy_and_use = Moveable{T={x = G.deck.T.x + 0.2, y = G.deck.T.y - 5.1, w = G.deck.T.w-0.1, h = 4.5}},
            S_pre_order = Moveable{T={x = G.deck.T.x + 0.2, y = G.deck.T.y - 5.1, w = G.deck.T.w-0.1, h = 4.5}},
            S_deposit = Moveable{T={x = G.deck.T.x + 0.2, y = G.deck.T.y, w = G.deck.T.w-0.1, h = G.deck.T.h+0.6}},
            N_recover = Moveable{T={x = G.deck.T.x + 0.2, y = G.deck.T.y, w = G.deck.T.w-0.1, h = G.deck.T.h+0.6}},
            C_use = Moveable{T={x = G.deck.T.x + 0.2, y = G.deck.T.y - 5.1, w = G.deck.T.w-0.1, h =4.5}},
            P_select = Moveable{T={x = G.play.T.x, y = G.play.T.y - 2, w = G.play.T.w + 2, h = G.play.T.h + 1}},
            W_hide = Moveable{T={x = G.deck.T.x + 0.2, y = G.deck.T.y - 5.1, w = G.deck.T.w-0.1, h = 4.5}},
            W_restore = Moveable{T={x = G.deck.T.x + 0.2, y = G.deck.T.y - 5.1, w = G.deck.T.w-0.1, h = 4.5}},
        }

        if _card.area and (_card.area == G.shop_jokers or _card.area == G.shop_vouchers or _card.area == G.shop_booster) then
            local buy_loc = copy_table(localize((_card.area == G.shop_vouchers and 'ml_redeem_target') or (_card.area == G.shop_booster and 'ml_open_target') or 'ml_buy_target'))
            buy_loc[#buy_loc + 1] = '$'.._card.cost
            drag_target({ cover = G.DRAG_TARGETS.S_buy, colour = adjust_alpha(G.C.GREEN, 0.9), text = buy_loc,
                card = _card,
                active_check = (function(other)
                    return G.FUNCS.can_buy_touch(other)
                end),
                release_func = (function(other)
                    if other.area == G.shop_jokers and G.FUNCS.can_buy_touch(other) then 
                        if G.OVERLAY_TUTORIAL and G.OVERLAY_TUTORIAL.button_listen == 'buy_from_shop' then
                          G.FUNCS.tut_next()
                        end
                        G.FUNCS.buy_from_shop({config = {
                            ref_table = other,
                            id = 'buy'
                        }})
                        return
                    elseif other.area == G.shop_vouchers and G.FUNCS.can_buy_touch(other) then
                        G.FUNCS.use_card({config={ref_table = other}})
                    elseif other.area == G.shop_booster and G.FUNCS.can_buy_touch(other) then
                        G.FUNCS.use_card({config={ref_table = other}})
                    end
                end)
            })
            local deposit_loc = {localize('b_deposit')}
            deposit_loc[#deposit_loc + 1] = '$'..1
            drag_target({ cover = G.DRAG_TARGETS.S_deposit, colour = adjust_alpha(HEX("8fbc8f"), 0.9), text = deposit_loc,
                card = _card,
                active_check = (function(other)
                    return G.FUNCS.can_deposit_touch(other)
                end),
                release_func = (function(other)
                    if G.FUNCS.can_deposit_touch(other) then 
                        G.FUNCS.deposit_from_shop({config = {
                            ref_table = other,
                            id = 'deposit'
                        }})
                        return
                    end
                end)
            })
            if G.FUNCS.can_buy_and_use_touch(_card) then
                local buy_use_loc = copy_table(localize('ml_buy_and_use_target'))
                buy_use_loc[#buy_use_loc + 1] = '$'.._card.cost
                drag_target({ cover = G.DRAG_TARGETS.S_buy_and_use, colour = adjust_alpha(G.C.ORANGE, 0.9),text=buy_use_loc,
                    card = _card,
                    active_check = (function(other)
                        return G.FUNCS.can_buy_and_use_touch(other)
                    end),  
                    release_func = (function(other)
                        if G.FUNCS.can_buy_and_use_touch(other) then 
                            G.FUNCS.buy_from_shop({config = {
                                ref_table = other,
                                id = 'buy_and_use'
                            }})
                            return
                        end
                    end)
                })
            end
            if G.FUNCS.can_hide_card_touch(_card) then
                local pre_order_loc = {localize('b_pre_order')}
                drag_target({ cover = G.DRAG_TARGETS.S_pre_order, colour = adjust_alpha(G.C.ORANGE, 0.9),text=pre_order_loc,
                    card = _card,
                    active_check = (function(other)
                        return G.FUNCS.can_hide_card_touch(other)
                    end),  
                    release_func = (function(other)
                        if G.FUNCS.can_hide_card_touch(other) then 
                            G.FUNCS.hide_card({config = {
                                ref_table = other,
                                id = 'pre_order'
                            }})
                            return
                        end
                    end)
                })
            end
        end
        
        if _card.area and (_card.area == G.pack_cards) then
            if _card.ability.consumeable and not (_card.ability.set == 'Planet') then
                drag_target({ cover = G.DRAG_TARGETS.C_use, colour = adjust_alpha(G.C.RED, 0.9),text = {localize('b_use')},
                    card = _card,
                    active_check = (function(other)
                        return G.FUNCS.can_use_touch(other)
                    end),
                    release_func = (function(other)
                        if G.FUNCS.can_use_touch(other) then
                            G.FUNCS.use_card({config={ref_table = other}})
                            return
                        end
                    end)
                })
            else 
                drag_target({ cover = G.DRAG_TARGETS.P_select, colour = adjust_alpha(G.C.GREEN, 0.9), text = {localize('b_select')},
                    card = _card,
                    active_check = (function(other)
                        return G.FUNCS.can_select_card_touch(other)
                    end),
                    release_func = (function(other)
                        if G.FUNCS.can_select_card_touch(other) then 
                            G.FUNCS.use_card({config={ref_table = other}})
                            return
                        end
                    end)
                })
            end
        end

        if _card.area and (_card.area == G.new_shop_deposit) then
            local recover_loc = {localize((_card.ability.supply and 'b_supply') or 'b_recover')}
            drag_target({ cover = G.DRAG_TARGETS.N_recover, colour = adjust_alpha(HEX("8fbc8f"), 0.9), text = recover_loc,
                card = _card,
                active_check = (function(other)
                    if _card.ability.supply then
                        return G.FUNCS.can_buy_new_touch(other)
                    else
                        return G.FUNCS.can_recover_touch(other)
                    end
                end),
                release_func = (function(other)
                    if _card.ability.supply then
                        if G.FUNCS.can_buy_new_touch(other) then
                            G.FUNCS.buy_from_new_shop({config = {
                                ref_table = other,
                                id = 'buy_new'
                            }})
                            return
                        end
                    else
                        if G.FUNCS.can_recover_touch(other) then
                            G.FUNCS.recover_from_new_shop({config = {
                                ref_table = other,
                                id = 'recover'
                            }})
                            return
                        end
                    end
                end)
            })
        end

        if _card.area and (_card.area == G.jokers or _card.area == G.consumeables) then 
            if _card.area == G.jokers then
                drag_target({ cover = G.DRAG_TARGETS.W_hide, colour = adjust_alpha(G.C.BLUE, 0.9),text={localize('b_hide')},
                    card = _card,
                    active_check = (function(other)
                        return G.FUNCS.can_hide_card_touch(other)
                    end),  
                    release_func = (function(other)
                        if G.FUNCS.can_hide_card_touch(other) then 
                            G.FUNCS.hide_card({config = {
                                ref_table = other,
                                id = 'hide'
                            }})
                            return
                        end
                    end)
                })
            end
            if _card.area == G.consumeables then
                drag_target({ cover = G.DRAG_TARGETS.C_use, colour = adjust_alpha(G.C.RED, 0.9),text={localize('b_use')},
                    card = _card,
                    active_check = (function(other)
                        return G.FUNCS.can_use_touch(other)
                    end),  
                    release_func = (function(other)
                        if G.FUNCS.can_use_touch(other) then 
                            G.FUNCS.use_card({config={ref_table = other}})
                            if G.OVERLAY_TUTORIAL and G.OVERLAY_TUTORIAL.button_listen == 'use_card' then
                                G.FUNCS.tut_next()
                            end
                            return
                        end
                    end)
                })
            end
        end

        if _card.area and (_card.area == G.bm_wallet) then
            drag_target({ cover = G.DRAG_TARGETS.W_restore, colour = adjust_alpha(G.C.BLUE, 0.9),text={localize('b_restore')},
                card = _card,
                active_check = (function(other)
                    return G.FUNCS.can_restore_card_touch(other)
                end),
                release_func = (function(other)
                    if G.FUNCS.can_restore_card_touch(other) then
                        G.FUNCS.restore_card({config = {
                            ref_table = other,
                            id = 'restore'
                        }})
                        return
                    end
                end)
            })
            if _card.ability.set == 'Joker' then
                if G.FUNCS.can_recycle_card_touch(_card) then
                    recycle_loc = {localize('b_recycle')}
                    recycle_loc[#recycle_loc + 1] = '$'..(G.GAME.recycle_cost or 2)
                    W_recycle = Moveable{T={x = G.jokers.T.x+4, y = G.jokers.T.y+4.3, w = G.jokers.T.w*0.37, h = G.jokers.T.h}}
                    drag_target({ cover = W_recycle, colour = adjust_alpha(G.C.MULT, 0.9),text=recycle_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_recycle_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_recycle_card_touch(other) then
                                G.FUNCS.recycle_card({config = {
                                    ref_table = other,
                                    id = 'recycle'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_maintenance_card_touch(_card) then
                    maintenance_loc = {localize('b_maintenance')}
                    maintenance_loc[#maintenance_loc + 1] = '$'..3*(G.GAME.perishable_rounds - _card.ability.perish_tally)
                    W_maintenance = Moveable{T={x = G.jokers.T.x+7.9, y = G.jokers.T.y+4.3, w = G.jokers.T.w*0.37, h = G.jokers.T.h}}
                    drag_target({ cover = W_maintenance, colour = adjust_alpha(G.C.SECONDARY_SET.Tarot, 0.9),text=maintenance_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_maintenance_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_maintenance_card_touch(other) then
                                G.FUNCS.maintenance_card({config = {
                                    ref_table = other,
                                    id = 'maintenance'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_package_card_touch(_card) then
                    package_loc = {localize('b_package')}
                    package_loc[#package_loc + 1] = '$'..(G.GAME.package_cost or 3)
                    package_loc[#package_loc + 1] = localize('b_package_2')..(G.GAME.used_times_consumeable_type or 0)..'/'..2
                    W_package = Moveable{T={x = G.shop_booster.T.x, y = G.shop_booster.T.y, w = G.shop_booster.T.w, h = G.shop_booster.T.h}}
                    drag_target({ cover = W_package, colour = adjust_alpha(G.C.SECONDARY_SET.Planet, 0.9),text=package_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_package_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_package_card_touch(other) then
                                G.FUNCS.package_card({config = {
                                    ref_table = other,
                                    id = 'package'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_printing_card_touch(_card) then
                    local printing_cost = _card:get_printing_cost()
                    printing_loc = {localize('b_printing')}
                    printing_loc[#printing_loc + 1] = '$'..printing_cost
                    W_printing = Moveable{T={x = G.shop_vouchers.T.x, y = G.shop_vouchers.T.y, w = G.shop_vouchers.T.w, h = G.shop_vouchers.T.h}}
                    drag_target({ cover = W_printing, colour = adjust_alpha(G.C.SECONDARY_SET.Spectral, 0.9),text=printing_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_printing_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_printing_card_touch(other) then
                                G.FUNCS.printing_card({config = {
                                    ref_table = other,
                                    id = 'printing'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_forge_card_touch(_card) and G.GAME.bmjokers then
                    forge_loc = {localize('b_forge_practice')}
                    forge_loc[#forge_loc + 1] = '$'..400
                    J_forge = Moveable{T={x = G.consumeables.T.x, y = G.consumeables.T.y, w = G.consumeables.T.w, h = G.consumeables.T.h}}
                    drag_target({ cover = J_forge, colour = adjust_alpha(G.C.SECONDARY_SET.Enhanced, 0.9),text=forge_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_forge_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_forge_card_touch(other) then
                                G.FUNCS.forge_card({config = {
                                    ref_table = other,
                                    id = 'forge'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_preach_room_touch(_card) and G.GAME.bmjokers then
                    preach_room1_loc = {localize('b_forge_practice_1')}
                    preach_room1_loc[#preach_room1_loc + 1] = '$'..400
                    Preach_room1 = Moveable{T={x = G.jokers.T.x+0.5, y = G.jokers.T.y+G.jokers.T.h+1, w = (G.deck.T.x-G.jokers.T.x)/2-1, h = G.consumeables.T.h}}
                    local cost2 = math.floor((G.GAME.dollars - G.GAME.bankrupt_at)/1600)*400
                    preach_room2_loc = {localize('b_forge_practice_2')}
                    preach_room2_loc[#preach_room2_loc + 1] = '$'..(cost2 >= 400 and cost2 or 400)
                    Preach_room2 = Moveable{T={x = (G.deck.T.x+G.jokers.T.x)/2+0.5, y = G.jokers.T.y+G.jokers.T.h+1, w = (G.deck.T.x-G.jokers.T.x)/2-1, h = G.consumeables.T.h}}
                    local cost3 = math.floor((G.GAME.dollars - G.GAME.bankrupt_at)/800)*400
                    preach_room3_loc = {localize('b_forge_practice_3')}
                    preach_room3_loc[#preach_room3_loc + 1] = '$'..(cost3 >= 400 and cost3 or 400)
                    Preach_room3 = Moveable{T={x = G.jokers.T.x+0.5, y = G.jokers.T.y+G.jokers.T.h+G.consumeables.T.h+1.5, w = (G.deck.T.x-G.jokers.T.x)/2-1, h = G.consumeables.T.h}}
                    local cost4 = math.floor((G.GAME.dollars - G.GAME.bankrupt_at)/400)*400
                    preach_room4_loc = {localize('b_forge_practice_4')}
                    preach_room4_loc[#preach_room4_loc + 1] = '$'..(cost4 >= 400 and cost4 or 400)
                    Preach_room4 = Moveable{T={x = (G.deck.T.x+G.jokers.T.x)/2+0.5, y = G.jokers.T.y+G.jokers.T.h+G.consumeables.T.h+1.5, w = (G.deck.T.x-G.jokers.T.x)/2-1, h = G.consumeables.T.h}}
                    drag_target({ cover = Preach_room1, colour = adjust_alpha(G.C.SECONDARY_SET.Enhanced, 0.9),text=preach_room1_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_preach_card1_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_preach_card1_touch(other) then
                                G.FUNCS.preach_card({config = {
                                    ref_table = other,
                                    cost = 400,
                                    id = 'preach'
                                }})
                                return
                            end
                        end)
                    })
                    drag_target({ cover = Preach_room2, colour = adjust_alpha(G.C.SECONDARY_SET.Enhanced, 0.9),text=preach_room2_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_preach_card2_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_preach_card2_touch(other) then
                                G.FUNCS.preach_card({config = {
                                    ref_table = other,
                                    cost = cost2,
                                    id = 'preach'
                                }})
                                return
                            end
                        end)
                    })
                    drag_target({ cover = Preach_room3, colour = adjust_alpha(G.C.SECONDARY_SET.Enhanced, 0.9),text=preach_room3_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_preach_card3_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_preach_card3_touch(other) then
                                G.FUNCS.preach_card({config = {
                                    ref_table = other,
                                    cost = cost3,
                                    id = 'preach'
                                }})
                                return
                            end
                        end)
                    })
                    drag_target({ cover = Preach_room4, colour = adjust_alpha(G.C.SECONDARY_SET.Enhanced, 0.9),text=preach_room4_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_preach_card1_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_preach_card1_touch(other) then
                                G.FUNCS.preach_card({config = {
                                    ref_table = other,
                                    cost = cost4,
                                    id = 'preach'
                                }})
                                return
                            end
                        end)
                    })
                end
            end
            if _card.ability.consumeable then
                if G.FUNCS.can_package_card_touch(_card) then
                    package_loc = {localize('b_package')}
                    package_loc[#package_loc + 1] = '$'..(G.GAME.package_cost or 3)
                    package_loc[#package_loc + 1] = localize('b_package_2')..(G.GAME.used_times_consumeable_type or 0)..'/'..2
                    W_package = Moveable{T={x = G.shop_booster.T.x, y = G.shop_booster.T.y, w = G.shop_booster.T.w, h = G.shop_booster.T.h}}
                    drag_target({ cover = W_package, colour = adjust_alpha(G.C.SECONDARY_SET.Planet, 0.9),text=package_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_package_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_package_card_touch(other) then
                                G.FUNCS.package_card({config = {
                                    ref_table = other,
                                    id = 'package'
                                }})
                                return
                            end
                        end)
                    })
                end
            end
            if _card.ability.set == 'Default' or _card.ability.set == 'Enhanced' then
                if G.FUNCS.can_printing_card_touch(_card) then
                    local printing_cost = _card:get_printing_cost()
                    printing_loc = {localize('b_printing')}
                    printing_loc[#printing_loc + 1] = '$'..printing_cost
                    W_printing = Moveable{T={x = G.shop_vouchers.T.x, y = G.shop_vouchers.T.y, w = G.shop_vouchers.T.w, h = G.shop_vouchers.T.h}}
                    drag_target({ cover = W_printing, colour = adjust_alpha(G.C.SECONDARY_SET.Spectral, 0.9),text=printing_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_printing_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_printing_card_touch(other) then
                                G.FUNCS.printing_card({config = {
                                    ref_table = other,
                                    id = 'printing'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_forge_card_touch(_card) then
                    forge_loc = {localize('b_forge')}
                    forge_loc[#forge_loc + 1] = '$'..(10 + (_card.ability.f_level or 0)*3)
                    forge_loc[#forge_loc + 1] = localize('b_forge_percentage')..string.format("%.0f", (G.GAME.probabilities.normal/(_card.ability.f_level/3 + 1)*100))..'%'
                    P_forge = Moveable{T={x = G.shop_booster.T.x, y = G.shop_booster.T.y, w = G.shop_booster.T.w, h = G.shop_booster.T.h}}
                    drag_target({ cover = P_forge, colour = adjust_alpha(G.C.SECONDARY_SET.Enhanced, 0.9),text=forge_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_forge_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_forge_card_touch(other) then
                                G.FUNCS.forge_card({config = {
                                    ref_table = other,
                                    id = 'forge'
                                }})
                                return
                            end
                        end)
                    })
                end
                if G.FUNCS.can_seal_card_touch(_card) then
                    seal_loc = {localize('b_seal')}
                    seal_loc[#seal_loc + 1] = '$'..15
                    P_seal = Moveable{T={x = G.jokers.T.x+7.9, y = G.jokers.T.y+4.3, w = G.jokers.T.w*0.37, h = G.jokers.T.h}}
                    drag_target({ cover = P_seal, colour = adjust_alpha(G.C.SECONDARY_SET.Voucher, 0.9),text=seal_loc,
                        card = _card,
                        active_check = (function(other)
                            return G.FUNCS.can_seal_card_touch(other)
                        end),
                        release_func = (function(other)
                            if G.FUNCS.can_seal_card_touch(other) then
                                G.FUNCS.seal_card({config = {
                                    ref_table = other,
                                    id = 'seal'
                                }})
                                return
                            end
                        end)
                    })
                end
            end
        end
    end
end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''function create_toggle(args)'''
position = "before"
payload = '''
function drag_target(args)
    args = args or {}
    args.text = args.text or {'BUY'}
    args.colour = copy_table(args.colour or G.C.UI.TRANSPARENT_DARK)
    args.cover = args.cover or nil
    args.emboss = args.emboss or nil
    args.active_check = args.active_check or (function(other) return true end)
    args.release_func = args.release_func or (function(other) G.DEBUG_VALUE = 'WORKIN' end)
    args.text_colour = copy_table(G.C.WHITE)
    args.uibox_config = {
      align = args.align or 'tli',
      offset = args.offset or {x=0,y=0}, 
      major = args.cover or args.major or nil,
    }

    local drag_area_width =(args.T and args.T.w or args.cover and args.cover.T.w or 0.001) + (args.cover_padding or 0)

    local text_rows = {}
    for k, v in ipairs(args.text) do
        text_rows[#text_rows+1] = {n=G.UIT.R, config={align = "cm", padding = 0.05, maxw = drag_area_width-0.1}, nodes={{n=G.UIT.O, config={object = DynaText({scale = args.scale, string = v, maxw = args.maxw or (drag_area_width-0.1), colours = {args.text_colour},float = true, shadow = true, silent = not args.noisy, 0.7, pop_in = 0, pop_in_rate = 6, rotate = args.rotate or nil})}}}}
    end

    args.DT = UIBox{
        T = {0,0,0,0},
        definition = 
          {n=G.UIT.ROOT, config = {align = 'cm',  args = args, can_collide = true, hover = true, release_func = args.release_func, func = 'check_drag_target_active', minw = drag_area_width, minh = (args.cover and args.cover.T.h or 0.001) + (args.cover_padding or 0), padding = 0.03, r = 0.1, emboss = args.emboss, colour = G.C.CLEAR}, nodes=text_rows}, 
        config = args.uibox_config
    }
    args.DT.attention_text = true

    if G.OVERLAY_TUTORIAL and G.OVERLAY_TUTORIAL.highlights then 
        G.OVERLAY_TUTORIAL.highlights[#G.OVERLAY_TUTORIAL.highlights+1] = args.DT
    end

    G.E_MANAGER:add_event(Event({trigger = 'after',delay = 0,blockable = false,blocking = false,func = function()
        if not G.CONTROLLER.dragging.target and args.DT then 
            if G.OVERLAY_TUTORIAL and G.OVERLAY_TUTORIAL.highlights then
                for k, v in ipairs(G.OVERLAY_TUTORIAL.highlights) do
                    if args.DT == v then 
                        table.remove(G.OVERLAY_TUTORIAL.highlights, k)
                        break
                    end
                end
            end
            args.DT:remove()
        return true end 
    end}))
end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = '''self.cursor_up.handled = true'''
position = "before"
payload = '''
        if self.cursor_down.target and self.dragging.prev_target then
            local releasable = nil
            for _, v in ipairs(self.collision_list) do
                if v.states.hover.can and (not v.states.drag.is) and (v ~= self.dragging.prev_target) then
                    releasable = v
                    break 
                end
            end
            if releasable and releasable.states.release_on.can then 
                self.released_on.target = releasable
                self.released_on.handled = false
            end
        end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = '''--The object being dragged'''
position = "before"
payload = '''
    if self.is_cursor_down then 
        self.cursor_down.distance = math.max(Vector_Dist(self.cursor_down.T, self.cursor_hover.T), self.cursor_down.distance or 0)
    else
        self.cursor_down.distance = nil
    end
    if not self.dragging.handled and self.cursor_down.distance and (self.cursor_down.distance > 0.2) then
        create_drag_target_from_card(self.dragging.target)
        self.dragging.handled = true
    end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/controller.lua"
pattern = '''if not self.released_on.handled and self.dragging.prev_target then'''
position = "at"
payload = '''
if not self.released_on.handled and self.released_on.target and self.dragging.prev_target then
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = '''if self.parent then self.parent:release(other) end'''
position = "before"
payload = '''
    if self.config.release_func then 
        self.config.release_func(other)
    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "engine/ui.lua"
pattern = '''--Draw the outline for highlighted buttons'''
position = "before"
payload = '''
    if self.config.pulse_border then
        self.border_pulse_timer = self.border_pulse_timer or G.TIMERS.REAL
        local lw = 2*math.max(0, 0.5*math.cos(6*(G.TIMERS.REAL - self.border_pulse_timer)) + 0.5)
        prep_draw(self, 1)
        love.graphics.scale((1)/(G.TILESIZE))
        love.graphics.setLineWidth(lw + 1)
        love.graphics.setColor(adjust_alpha(G.C.BLACK, 0.2*lw, true))
        self:draw_pixellated_rect('fill', parallax_dist)
        love.graphics.setColor(self.config.colour[4] > 0 and mix_colours(G.C.WHITE, self.config.colour, 0.8) or G.C.WHITE)
        self:draw_pixellated_rect('line', parallax_dist)
        love.graphics.pop()
    end
    
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''if self.STATE == self.STATES.BUFFOON_PACK then'''
position = "before"
payload = '''
        if G.GAME.new_shop then
            self:update_new_shop(dt)
        end

        if G.GAME.preach then
            self:update_preach_room(dt)
        end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''reroll_cost_increase = 0,'''
position = "after"
payload = '''
            reroll_new_cost = 20,
            reroll_new_cost_increase = 0,
            kickback = 0,
            kickback_total = 1,
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''if card:check_use() then'''
position = "before"
payload = '''
    if ((G.GAME.preach and G.preach_room) or (G.GAME.new_shop and G.new_shop)) then
      nosave = true
    end

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''if G.shop and not G.shop.alignment.offset.py then'''
position = "before"
payload = '''
    if G.preach_room and not G.preach_room.alignment.offset.py and (card.ability.consumeable or not (G.FUNCS.can_preach_card1_touch(c1) or G.FUNCS.can_preach_card2_touch(c1) or G.FUNCS.can_preach_card3_touch(c1))) then
      G.preach_room.alignment.offset.py = G.preach_room.alignment.offset.y
      G.preach_room.alignment.offset.y = G.ROOM.T.y + 29
    end
    if G.new_shop and not G.new_shop.alignment.offset.py then
      G.new_shop.alignment.offset.py = G.new_shop.alignment.offset.y
      G.new_shop.alignment.offset.y = G.ROOM.T.y + 29
    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''if (prev_state == G.STATES.TAROT_PACK or prev_state == G.STATES.PLANET_PACK or'''
position = "before"
payload = '''
                if G.GAME.preach and G.preach_room then
                  G.preach_room.alignment.offset.y = G.preach_room.alignment.offset.py
                  G.preach_room.alignment.offset.py = nil
                end
                if G.GAME.new_shop and G.new_shop then
                  G.new_shop.alignment.offset.y = G.new_shop.alignment.offset.py
                  G.new_shop.alignment.offset.py = nil
                end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''if G.blind_select and G.blind_select.alignment.offset.py then'''
position = "before"
payload = '''
                if G.preach_room and G.preach_room.alignment.offset.py then 
                  G.preach_room.alignment.offset.y = G.preach_room.alignment.offset.py
                  G.preach_room.alignment.offset.py = nil
                end
                if G.new_shop and G.new_shop.alignment.offset.py then 
                  G.new_shop.alignment.offset.y = G.new_shop.alignment.offset.py
                  G.new_shop.alignment.offset.py = nil
                end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.shop.alignment.offset.y = G.shop.alignment.offset.py'''
position = "before"
payload = '''
                  if not (G.GAME.preach or G.GAME.new_shop) then
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.shop.alignment.offset.py = nil'''
position = "after"
payload = '''
                  end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "cardarea.lua"
pattern = '''(self.config.type == 'deck' and self ~= G.deck) or'''
position = "before"
payload = '''
        (self.config.type == 'new_shop') or
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.FUNCS.draw_from_hand_to_deck()'''
position = "before"
payload = '''
      if (G.shop or G.blind_select or G.round_eval) then
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.FUNCS.draw_from_hand_to_deck()'''
position = "after"
payload = '''
      end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.deck:emplace(card)'''
position = "at"
payload = '''
    if G.hand.cards[1] then
     G.hand:emplace(card)
     G.hand:sort()
    else
     G.deck:emplace(card)
    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "cardarea.lua"
pattern = '''if self.config.type == 'title' or (self.config.type == 'voucher' and #self.cards == 1) then'''
position = "before"
payload = '''
    if self.config.type == 'hand' and (G.STATE == G.STATES.STANDARD_PACK or G.STATE == G.STATES.BUFFOON_PACK) then
        for k, card in ipairs(self.cards) do
            if not card.states.drag.is then 
                card.T.r = 0.4*(-#self.cards/2 - 0.5 + k)/(#self.cards)+ (G.SETTINGS.reduced_motion and 0 or 1)*0.02*math.sin(2*G.TIMERS.REAL+card.T.x)
                local max_cards = math.max(#self.cards, self.config.temp_limit)
                card.T.x = self.T.x + (self.T.w-self.card_w)*((k-1)/math.max(max_cards-1, 1) - 0.5*(#self.cards-max_cards)/math.max(max_cards-1, 1)) + 0.5*(self.card_w - card.T.w)
                local highlight_height = G.HIGHLIGHT_H
                if not card.highlighted then highlight_height = 0 end
                card.T.y = G.hand.T.y - 1.8*card.T.h - highlight_height + (G.SETTINGS.reduced_motion and 0 or 1)*0.1*math.sin(0.666*G.TIMERS.REAL+card.T.x) + math.abs(1.3*(-#self.cards/2 + k-0.5)/(#self.cards))^2-0.3
                card.T.x = card.T.x + card.shadow_parrallax.x/30
            end
        end
        table.sort(self.cards, function (a, b) return a.T.x + a.T.w/2 < b.T.x + b.T.w/2 end)
    end
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''if self.area and self.ability.couponed and (self.area == G.shop_jokers or self.area == G.shop_booster) then self.cost = 0 end'''
position = "after"
payload = '''
if self.area and self.ability.couponed and (self.area == G.new_shop_deposit) then self.cost = 0 end
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "globals.lua"
pattern = '''DARK_EDITION = {0,0,0,1},'''
position = "after"
payload = '''
NEBULA_BLUE = {0,0,0,1},
RUBY_RED = {0,0,0,1},
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = '''dark_edition = G.C.DARK_EDITION,'''
position = "after"
payload = '''
nebula_blue = G.C.NEBULA_BLUE,
ruby_red = G.C.RUBY_RED,
'''
match_indent = true
overwrite = false

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''self.C.DARK_EDITION[1] = 0.6+0.2*math.sin(self.TIMERS.REAL*1.3)'''
position = "before"
payload = '''
        self.C.NEBULA_BLUE[1] = 0.15+0.05*math.sin(self.TIMERS.REAL*1.8)
        self.C.NEBULA_BLUE[2] = 0.4+0.3*math.sin(self.TIMERS.REAL*1.8)
        self.C.NEBULA_BLUE[3] = 0.9+0.1*math.cos(self.TIMERS.REAL*1.8)

        self.C.RUBY_RED[1] = 0.95+0.05*math.sin(self.TIMERS.REAL*1.8)
        self.C.RUBY_RED[2] = 0.5+0.25*math.sin(self.TIMERS.REAL*1.8)
        self.C.RUBY_RED[3] = 0.3+0.2*math.cos(self.TIMERS.REAL*1.8)

'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''G.SHOP_SIGN = UIBox{'''
position = "before"
payload = '''
    G.NEW_SHOP_ENTER = UIBox{
      definition = 
        {n=G.UIT.ROOT, config={align = "cm", padding = 0.05, colour = G.C.CLEAR}, nodes={
          UIBox_button({label = {localize('b_enter')}, minw = 3.7, button = "new_shop", func = 'can_new_shop'})
        }},
      config = {
        align="cm",
        offset = {x=0.03,y=-15},
        major = G.HUD:get_UIE_by_ID('hand_chip_total'),
        bond = 'Weak'
      }
    }
    G.E_MANAGER:add_event(Event({
      trigger = 'immediate',
      func = (function()
          G.NEW_SHOP_ENTER.alignment.offset.y = 0.03
          return true
      end)
    }))
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.SHOP_SIGN.alignment.offset.y = -15'''
position = "after"
payload = '''
          G.NEW_SHOP_ENTER.alignment.offset.y = -15
'''
match_indent = false
overwrite = false

[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = '''G.SHOP_SIGN = nil'''
position = "after"
payload = '''
          G.NEW_SHOP_ENTER:remove()
          G.NEW_SHOP_ENTER = nil
'''
match_indent = false
overwrite = false

